# Cisco Support MCP Server

A comprehensive TypeScript MCP (Model Context Protocol) server for Cisco Support APIs with both stdio and HTTP transport support. This extensible server currently provides access to Cisco's Bug Search API and is designed to support additional Cisco Support tools in the future.

## Project Overview

This TypeScript server features:
- **Dual Transport Support**: stdio (local MCP) and HTTP (remote server)
- **Extensible Architecture**: Designed to support multiple Cisco Support APIs
- OAuth2 authentication with Cisco API (client credentials flow)
- 8 MCP-compliant tools for comprehensive bug searching (with more tools planned)
- Real-time updates via Server-Sent Events (HTTP mode)
- TypeScript with full type safety and MCP SDK integration
- Docker containerization with multi-stage builds
- NPX support for easy local installation
- Security best practices

## Project Structure

```
mcp-cisco-support/
├── src/
│   └── index.ts        # Main TypeScript server implementation
├── dist/               # Compiled JavaScript (generated by build)
├── package.json        # Dependencies and scripts
├── tsconfig.json       # TypeScript configuration
├── .env.example       # Environment variables template
├── .env               # Actual environment variables (create from example)
├── .gitignore         # Git ignore rules
├── Dockerfile         # Docker configuration
├── docker-compose.yml # Docker Compose setup
└── README.md          # Project documentation
```

## Dependencies

Install these npm packages:
```json
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.12.1",
    "express": "^4.18.2",
    "cors": "^2.8.5", 
    "helmet": "^7.1.0",
    "morgan": "^1.10.0",
    "uuid": "^9.0.1",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/morgan": "^1.9.9",
    "@types/node": "^20.10.0",
    "@types/uuid": "^9.0.7",
    "typescript": "^5.8.3",
    "tsx": "^4.6.2"
  }
}
```

## Quick Start

### Local MCP Server (stdio)
```bash
# Install globally via NPX
npx mcp-cisco-support

# Or install and run locally
npm install
npm run build
npm run stdio
```

### HTTP Server
```bash
# Development mode
npm run dev

# Production mode
npm run build
npm start
```

## MCP Client Configuration

### Using with Claude Desktop

Add this configuration to your Claude Desktop settings file:

**On macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
**On Windows**: `%APPDATA%\Claude\claude_desktop_config.json`

```json
{
  "mcpServers": {
    "cisco-support": {
      "command": "npx",
      "args": ["mcp-cisco-support"],
      "env": {
        "CISCO_CLIENT_ID": "your_client_id_here",
        "CISCO_CLIENT_SECRET": "your_client_secret_here"
      }
    }
  }
}
```

### Example Usage

Once configured, you can ask Claude questions like:

- **Basic Bug Search**:
  - "Search for recent bugs related to 'crash' in Cisco products"
  - "Find open bugs with severity 1 or 2"
  - "Show me bugs modified in the last 30 days"

- **Product-Specific Searches**:
  - "Find bugs for product ID WS-C3560-48PS-S"
  - "Search for bugs in Cisco Catalyst 3560 Series affecting release 15.2(4)S"
  - "Show bugs fixed in software release 15.2(4)S2"

- **Advanced Filtering**:
  - "Find resolved bugs with severity 3 modified after 2023-01-01"
  - "Search for bugs in 'Cisco ASR 9000 Series' sorted by severity"
  - "Can you show me all the cisco bugs in the last 30 days for the product Cisco Unified Communications Manager (CallManager)?" (uses keyword search)
  - "Find bugs for Cisco Unified Communications Manager affecting releases 14.0 and 15.0" (uses product series search)

### Using with Other MCP Clients

For stdio transport:
```bash
mcp-cisco-support --stdio
```

For HTTP transport:
```bash
mcp-cisco-support --http
# Server will start on http://localhost:3000
```

### MCP Inspector v0.14.0+ Compatibility

This server fully supports MCP Inspector v0.14.0+ including:
- **Ping method**: Test connectivity and server responsiveness
- **Standard MCP protocol**: initialize, tools/list, tools/call
- **Both transports**: stdio for local inspection, HTTP for remote testing

To test with MCP Inspector:
1. Start the server: `mcp-cisco-support --stdio`
2. Connect MCP Inspector to the stdio transport
3. Use the ping feature to test connectivity
4. Explore available tools and test tool calls

## NPX Installation and Setup

### Publishing to NPM (for npx support)

1. Update package.json version and author information
2. Build the project: `npm run build`
3. Publish to NPM: `npm publish`
4. Install globally: `npm install -g mcp-cisco-support`
5. Use via npx: `npx mcp-cisco-support`

### Local NPX Setup (for development)

1. Build the project: `npm run build`
2. Link globally: `npm link`
3. Use via npx: `npx mcp-cisco-support`

## Transport Modes

### stdio Transport (Default)
- **Use case**: Local MCP clients (Claude Desktop, etc.)
- **Protocol**: JSON-RPC over stdio
- **Command**: `mcp-cisco-support` or `mcp-cisco-support --stdio`
- **Benefits**: Direct integration with MCP clients, no network overhead

### HTTP Transport
- **Use case**: Remote server, web applications, SSE clients
- **Protocol**: JSON-RPC over HTTP + Server-Sent Events
- **Command**: `mcp-cisco-support --http`
- **Port**: 3000 (configurable via PORT env var)
- **Endpoints**:
  - `POST /mcp` - MCP JSON-RPC endpoint (supports ping method)
  - `GET /ping` - Simple ping endpoint for connectivity testing
  - `GET /sse` - Server-Sent Events stream
  - `GET /health` - Health check
  - `GET /` - Server information

## Build Commands

```bash
# Install dependencies
npm install

# Build TypeScript to JavaScript
npm run build

# Development with hot reload
npm run dev

# Run in stdio mode (default)
npm run stdio
# or
npm start

# Run in HTTP mode
npm start -- --http

# Type checking
npx tsc --noEmit

# Test ping functionality (HTTP mode)
curl http://localhost:3000/ping

# Test MCP ping via JSON-RPC (HTTP mode)
curl -X POST http://localhost:3000/mcp \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"ping"}'

# GitHub Actions monitoring
npm run actions:status    # Check latest build status
npm run actions:list      # List recent workflow runs
npm run actions:watch     # Watch current run in real-time
npm run actions:logs      # View logs of latest run
```

## Environment Variables

Create `.env.example` and `.env` files with:
```bash
# Cisco API OAuth2 Configuration
CISCO_CLIENT_ID=your_client_id_here
CISCO_CLIENT_SECRET=your_client_secret_here

# Server Configuration
PORT=3000
NODE_ENV=development
```

## API Endpoints

The server implements these Cisco Bug API v2.0 endpoints:

### Authentication
- **OAuth2 URL**: `https://id.cisco.com/oauth2/default/v1/token`
- **Grant Type**: `client_credentials`
- **Token Validity**: 12 hours
- **Auto-refresh**: 30 minutes before expiry

### Bug API Base URL
- **Base URL**: `https://apix.cisco.com/bug/v2.0`

## MCP Tools to Implement

1. **get_bug_details** - Get details for up to 5 specific bug IDs
2. **search_bugs_by_keyword** - Search by keywords in descriptions/headlines  
3. **search_bugs_by_product_id** - Search by base product ID (e.g., "WS-C3560-48PS-S")
4. **search_bugs_by_product_and_release** - Search by product ID + software releases
5. **search_bugs_by_product_series_affected** - Search by product series + affected releases
6. **search_bugs_by_product_series_fixed** - Search by product series + fixed releases
7. **search_bugs_by_product_name_affected** - Search by exact product name + affected releases
8. **search_bugs_by_product_name_fixed** - Search by exact product name + fixed releases

## Server Endpoints

- `GET /` - Server info and available endpoints
- `GET /api/mcp/tools` - List all available MCP tools
- `POST /api/mcp/call` - Execute MCP tool calls
- `GET /api/sse` - Server-Sent Events endpoint for real-time updates
- `GET /health` - Health check endpoint

## Key Features

### OAuth2 Authentication
- Automatic token management with refresh
- Handle 401 responses by refreshing token
- Store token and expiry in memory

### Error Handling
- Comprehensive error handling for network issues
- Timeout handling (30 seconds)
- Proper HTTP status codes
- Detailed logging

### Server-Sent Events
- Real-time updates for tool execution
- Connection management
- Heartbeat messages every 30 seconds
- Graceful disconnect handling

### Security
- Helmet for security headers
- CORS enabled
- Input validation
- Environment variable protection

## Docker Configuration

### Dockerfile Requirements
- Multi-stage TypeScript build with Node.js 18-alpine
- Non-root user execution for security
- Health checks and proper monitoring
- Multi-platform support (linux/amd64, linux/arm64)
- Build optimization with layer caching
- Proper file permissions and labels

### Docker Compose
- Health checks and monitoring
- Environment variables configuration
- Volume mounts for logs
- Network configuration
- Restart policies

### GitHub Container Registry
Automated Docker builds are available via GitHub Actions:
- **Latest**: `ghcr.io/sieteunoseis/mcp-cisco-support:latest`
- **Tagged**: `ghcr.io/sieteunoseis/mcp-cisco-support:v1.0.0`
- **Branch**: `ghcr.io/sieteunoseis/mcp-cisco-support:main-abc123`

Pull and run the pre-built image:
```bash
docker pull ghcr.io/sieteunoseis/mcp-cisco-support:latest
docker run -d -p 3000:3000 \
  -e CISCO_CLIENT_ID=your_id \
  -e CISCO_CLIENT_SECRET=your_secret \
  ghcr.io/sieteunoseis/mcp-cisco-support:latest --http
```

## CI/CD Workflows

### GitHub Actions
The project includes automated workflows for:

#### Docker Build (`docker-build.yml`)
- **Triggers**: Push to main/master, manual dispatch
- **Multi-platform**: Builds for linux/amd64 and linux/arm64
- **Registry**: Pushes to GitHub Container Registry (ghcr.io)
- **Caching**: Uses GitHub Actions cache for faster builds
- **Security**: Includes build provenance attestation
- **Tagging**: Automatic versioning and latest tags

#### NPM Publish (`npm-publish.yml`)
- **Triggers**: GitHub releases, manual dispatch with dry-run option
- **Features**: TypeScript compilation, version management, provenance
- **Registry**: Publishes to NPM registry
- **Security**: Uses NPM provenance for supply chain security

### Setup Requirements
To enable the workflows, configure these repository secrets:
- `NPM_TOKEN`: NPM authentication token for publishing
- `GITHUB_TOKEN`: Automatically provided by GitHub

### Manual Workflow Dispatch
Both workflows can be triggered manually:
- **Docker Build**: With optional custom tag suffix
- **NPM Publish**: With dry-run option for testing

### Monitoring GitHub Actions

Use these npm scripts to monitor workflow runs:

```bash
# Quick status check
npm run actions:status

# List recent workflow runs
npm run actions:list

# Watch current run in real-time
npm run actions:watch

# View logs of latest run
npm run actions:logs
```

**Direct GitHub CLI commands:**
```bash
# Check specific run by ID
gh run view <run-id>

# View logs of specific run
gh run view <run-id> --log

# Re-run a failed workflow
gh run rerun <run-id>

# Cancel a running workflow
gh run cancel <run-id>
```

## Implementation Guidelines

1. **TypeScript with strict mode** for type safety
2. **MCP SDK integration** for protocol compliance
3. **Dual transport support** (stdio and HTTP)
4. **Use native fetch** instead of axios
5. **Implement proper pagination** (10 results per page)
6. **Handle all filter parameters** (status, severity, modified_date, sort_by)
7. **JSON Schema validation** for input validation
8. **Broadcast SSE events** for tool execution start/complete/error (HTTP mode)
9. **Use URLSearchParams** for query string building
10. **Implement graceful shutdown** handling
11. **Add comprehensive logging** with timestamps
12. **Include proper TypeScript types** and JSDoc comments

## Testing Considerations

Ensure the server handles:
- Invalid credentials
- Network timeouts
- Malformed requests
- Large result sets
- Concurrent requests
- SSE connection drops

## Example Tool Schema

Each tool should have proper input schema validation:
```javascript
{
  name: 'search_bugs_by_keyword',
  description: 'Search for bugs using keywords in descriptions and headlines',
  inputSchema: {
    type: 'object',
    properties: {
      keyword: {
        type: 'string',
        description: 'Keywords to search for'
      },
      page_index: {
        type: 'integer',
        default: 1,
        description: 'Page number (10 results per page)'
      },
      // ... other parameters
    },
    required: ['keyword']
  }
}
```

## Cisco API Reference

Reference the official documentation at:
- https://developer.cisco.com/docs/support-apis/bug/

Key API patterns:
- `/bugs/bug_ids/{bug_ids}` - Get specific bugs
- `/bugs/keyword/{keyword}` - Search by keyword
- `/bugs/products/product_id/{base_pid}` - Search by product
- `/bugs/product_series/{series}/affected_releases/{releases}` - Product series queries

Start by setting up the basic Express server structure, then implement OAuth2 authentication, followed by the MCP tools and SSE functionality.

## Troubleshooting

### Claude Desktop Integration Issues

#### Common Problems

1. **JSON-RPC parsing errors in stdio mode**:
   - Ensure logging is disabled in stdio mode to prevent interference
   - Check that console output doesn't contain non-JSON-RPC messages

2. **Connection refused errors**:
   - ✅ **FIXED in v1.3.0**: Added proper `/mcp` endpoint with StreamableHTTP transport
   - Use `http://localhost:3000/mcp` for HTTP connections
   - Server supports both legacy `/sse` and standard `/mcp` endpoints

3. **API parameter validation errors**:
   - Don't send default status/severity parameters unless explicitly specified
   - Let Cisco API use its own defaults for broader compatibility

4. **Authentication failures**:
   - Verify CISCO_CLIENT_ID and CISCO_CLIENT_SECRET in environment
   - Ensure Cisco API application has proper permissions

#### Debugging Tools

**Monitor Claude Desktop logs in real-time**:
```bash
# macOS - Follow logs in real-time
tail -n 20 -F ~/Library/Logs/Claude/mcp*.log

# Look for specific error patterns
grep -i error ~/Library/Logs/Claude/mcp*.log
grep -i "cisco-support" ~/Library/Logs/Claude/mcp*.log
```

**Test server manually**:
```bash
# Test stdio mode
npx mcp-cisco-support

# Test HTTP mode with new /mcp endpoint
npx mcp-cisco-support --http
curl http://localhost:3000/health
curl -X POST http://localhost:3000/mcp -H "Content-Type: application/json" -H "Accept: application/json, text/event-stream" -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}'
```

#### MCP Endpoints (v1.3.0+)

**Primary MCP Endpoint** (recommended):
- `POST /mcp` - MCP JSON-RPC calls with session management
- `GET /mcp` - SSE streams for ongoing sessions  
- `DELETE /mcp` - Session termination

**Legacy Endpoints** (backward compatibility):
- `GET /sse` - Legacy SSE connection
- `POST /messages` - Legacy SSE messages

#### Log Analysis

Key log messages to monitor:
- `"Message from client"` - Incoming MCP requests
- `"Message from server"` - Outgoing MCP responses  
- `"Tool call started"` - API calls beginning
- `"Session initialized"` - New MCP sessions created
- `"error"` - Any error conditions

**Healthy connection logs should show**:
1. Server initialization
2. Client initialize request/response with session ID
3. tools/list requests/responses
4. No JSON parsing errors

## Development Roadmap

### Current API Implementation Status

| API | Status | Tools | Description |
|-----|--------|-------|-------------|
| **Bug** | ✅ **Implemented** | 8 tools | Bug Search, Details, Product-specific searches |
| **Case** | 🔄 **Planned** | 0 tools | Support case management and operations |
| **EoX** | 🔄 **Planned** | 0 tools | End of Life/Sale information and notifications |
| **Product** | 🔄 **Planned** | 0 tools | Product details, specifications, and information |
| **Serial** | 🔄 **Planned** | 0 tools | Serial number to product information mapping |
| **RMA** | 🔄 **Planned** | 0 tools | Return Merchandise Authorization processes |
| **Software** | 🔄 **Planned** | 0 tools | Software suggestions and recommendations |
| **ASD** | 🔄 **Planned** | 0 tools | Automated Software Distribution |

### Next Implementation Priorities

1. **Case Management API** - High priority for support workflows
   - Create/update/search support cases
   - Case status tracking and management
   - Attachment handling for cases

2. **EoX API** - Critical for lifecycle management
   - End of Life announcements
   - End of Sale notifications
   - Product lifecycle information

3. **Product Information API** - Essential for product research
   - Product specifications and details
   - Product family and series information
   - Product documentation links

4. **Serial Number API** - Important for asset tracking
   - Serial to product mapping
   - Warranty information lookup
   - Contract and coverage details

5. **Software Suggestion API** - Valuable for updates
   - Software recommendations
   - Update suggestions
   - Compatibility information

6. **RMA API** - Support for return processes
   - RMA request creation
   - Return status tracking
   - Return authorization management

7. **ASD API** - Automated distribution
   - Software distribution automation
   - Update deployment
   - Distribution tracking

### Architecture Benefits

The configurable API system provides:

- **Scalability**: Each API can be developed independently
- **User Control**: Users enable only APIs they have access to
- **Performance**: Smaller tool sets for faster initialization
- **Security**: No exposure of unauthorized API endpoints
- **Maintainability**: Clean separation by API functionality

### Implementation Framework

Each new API follows this pattern:

1. **API Tools Definition**: Create tool array for the API
2. **Schema Validation**: Define input schemas for all tools
3. **API Integration**: Implement Cisco API calls and authentication
4. **Response Formatting**: Add hyperlinks and structured output
5. **Error Handling**: Comprehensive error management
6. **Documentation**: Update README and examples
7. **Testing**: Validate with real API credentials

### Configuration Examples

Users can configure exactly what they need:

```bash
# Development/Testing - Bug API only
SUPPORT_API=bug

# Support Engineer - Case management focus
SUPPORT_API=bug,case,rma

# Product Manager - Product lifecycle focus  
SUPPORT_API=bug,eox,product,software

# Administrator - Full access
SUPPORT_API=all
```